import psycopg2
from collections import defaultdict
from typing import List, Dict, Optional
import logging

class RecommendationService:
    """
    Serwis rekomendacji plan√≥w treningowych na podstawie ankiety u≈ºytkownika.
    Implementuje algorytmy: content-based, collaborative filtering i hybrydowy.
    """
    
    def __init__(self, db_params: Dict):
        """
        Inicjalizacja serwisu z parametrami bazy danych.
        
        Args:
            db_params: S≈Çownik z parametrami po≈ÇƒÖczenia do bazy PostgreSQL
        """
        try:
            self.conn = psycopg2.connect(**db_params)
            logging.info("‚úÖ Po≈ÇƒÖczono z bazƒÖ danych.")
        except psycopg2.OperationalError as e:
            logging.error(f"‚ùå B≈ÅƒÑD PO≈ÅƒÑCZENIA Z BAZƒÑ: {e}")
            self.conn = None

    def _get_user_profile(self, auth_account_id: int) -> Optional[Dict]:
        """
        Pobiera profil u≈ºytkownika z ankiety.
        
        Args:
            auth_account_id: ID konta u≈ºytkownika
            
        Returns:
            S≈Çownik z danymi profilu lub None je≈õli nie znaleziono
        """
        if not self.conn:
            return None
            
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT goal, level, training_days_per_week, equipment_preference 
                FROM user_profiles 
                WHERE auth_account_id = %s
            """, (auth_account_id,))
            
            user_data = cur.fetchone()
            if not user_data:
                return None
                
            return {
                'goal': user_data[0],
                'level': user_data[1], 
                'days': user_data[2],
                'equipment': user_data[3]
            }

    def _recommend_content_based(self, user_profile: Dict) -> List[Dict]:
        """
        ALGORYTM CONTENT-BASED: Rekomenduje na podstawie dopasowania do ankiety.
        
        System punktacji:
        - Cel (goal_type): 10 punkt√≥w za dok≈Çadne dopasowanie
        - Poziom (difficulty_level): 8 punkt√≥w za dok≈Çadne dopasowanie  
        - Dni treningowe (training_days_per_week): 12 punkt√≥w za dok≈Çadne dopasowanie
        - Sprzƒôt (equipment_required): 5 punkt√≥w za dok≈Çadne dopasowanie
        
        Args:
            user_profile: Profil u≈ºytkownika z ankiety
            
        Returns:
            Lista plan√≥w z wynikami dopasowania, posortowana malejƒÖco
        """
        if not self.conn:
            return []
            
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT id, goal_type, difficulty_level, training_days_per_week, equipment_required 
                FROM training_plans
            """)
            all_plans = cur.fetchall()

        plan_scores = []
        for plan_data in all_plans:
            plan_id, goal, level, days, equipment = plan_data
            score = 0
            
            # Punktacja za dopasowanie
            if goal == user_profile['goal']:
                score += 10
            if level == user_profile['level']:
                score += 8
            if days == user_profile['days']:
                score += 12
            if equipment == user_profile['equipment']:
                score += 5

            if score > 0:
                plan_scores.append({'plan_id': plan_id, 'score': score})

        # Sortowanie malejƒÖco po wyniku
        plan_scores.sort(key=lambda x: x['score'], reverse=True)
        return plan_scores

    def _recommend_collaborative(self, auth_account_id: int, user_profile: Dict) -> List[Dict]:
        """
        ALGORYTM COLLABORATIVE FILTERING: Rekomenduje plany popularne w≈õr√≥d podobnych u≈ºytkownik√≥w.
        
        Logika:
        1. Znajd≈∫ u≈ºytkownik√≥w o podobnym profilu (cel + poziom)
        2. Znajd≈∫ plany, kt√≥re ci u≈ºytkownicy najczƒô≈õciej aktywowali
        3. Zwr√≥ƒá ranking popularno≈õci
        
        Args:
            auth_account_id: ID u≈ºytkownika (wykluczony z rekomendacji)
            user_profile: Profil u≈ºytkownika z ankiety
            
        Returns:
            Lista plan√≥w z wynikami popularno≈õci w≈õr√≥d podobnych u≈ºytkownik√≥w
        """
        if not self.conn:
            return []
            
        with self.conn.cursor() as cur:
            # Znajd≈∫ podobnych u≈ºytkownik√≥w (ten sam cel i poziom)
            cur.execute("""
                SELECT up.auth_account_id 
                FROM user_profiles up
                WHERE up.goal = %s AND up.level = %s AND up.auth_account_id != %s
                LIMIT 100
            """, (user_profile['goal'], user_profile['level'], auth_account_id))
            
            similar_users = [row[0] for row in cur.fetchall()]
            if not similar_users:
                return []

            # Znajd≈∫ plany popularne w≈õr√≥d podobnych u≈ºytkownik√≥w
            cur.execute("""
                SELECT plan_id, COUNT(id) as session_count 
                FROM training_sessions
                WHERE auth_account_id = ANY(%s) AND plan_id IS NOT NULL
                GROUP BY plan_id 
                ORDER BY session_count DESC
            """, (similar_users,))
            
            return [{'plan_id': row[0], 'score': row[1]} for row in cur.fetchall()]

    def _recommend_hybrid(self, auth_account_id: int, user_profile: Dict) -> List[Dict]:
        """
        ALGORYTM HYBRYDOWY: ≈ÅƒÖczy content-based i collaborative filtering.
        
        Strategia:
        1. Oblicz wyniki content-based (dopasowanie do ankiety)
        2. Oblicz wyniki collaborative (popularno≈õƒá w≈õr√≥d podobnych)
        3. Po≈ÇƒÖcz wyniki: content_score + (collaborative_score * 0.5)
        
        Args:
            auth_account_id: ID u≈ºytkownika
            user_profile: Profil u≈ºytkownika z ankiety
            
        Returns:
            Lista plan√≥w z hybrydowymi wynikami dopasowania
        """
        # Pobierz wyniki z obu algorytm√≥w
        content_results = self._recommend_content_based(user_profile)
        collaborative_results = self._recommend_collaborative(auth_account_id, user_profile)
        
        # Przekszta≈Çƒá collaborative na s≈Çownik dla szybkiego dostƒôpu
        collaborative_scores = {item['plan_id']: item['score'] for item in collaborative_results}
        
        # Po≈ÇƒÖcz wyniki
        hybrid_scores = []
        for plan in content_results:
            plan_id, content_score = plan['plan_id'], plan['score']
            
            # Dodaj bonus z collaborative (z mniejszƒÖ wagƒÖ)
            collaborative_bonus = collaborative_scores.get(plan_id, 0) * 0.5
            
            hybrid_scores.append({
                'plan_id': plan_id, 
                'score': content_score + collaborative_bonus
            })
            
        # Sortuj wed≈Çug ko≈Ñcowego wyniku
        hybrid_scores.sort(key=lambda x: x['score'], reverse=True)
        return hybrid_scores

    def get_recommendations(self, auth_account_id: int, mode: str = 'hybrydowo') -> List[Dict]:
        """
        G≈Ç√≥wna metoda publiczna do pobierania rekomendacji.
        
        Args:
            auth_account_id: ID u≈ºytkownika
            mode: Tryb algorytmu ('produkt', 'klient', 'hybrydowo')
            
        Returns:
            Lista rekomendowanych plan√≥w z wynikami dopasowania
        """
        if not self.conn:
            return []
            
        # Pobierz profil u≈ºytkownika
        user_profile = self._get_user_profile(auth_account_id)
        if not user_profile:
            logging.warning(f"Nie znaleziono profilu dla konta o ID: {auth_account_id}")
            return []
        
        logging.info(f"Generowanie rekomendacji dla u≈ºytkownika {auth_account_id}, tryb: {mode}")
        
        # Wybierz algorytm
        if mode == 'produkt':
            return self._recommend_content_based(user_profile)
        elif mode == 'klient':
            return self._recommend_collaborative(auth_account_id, user_profile)
        elif mode == 'hybrydowo':
            return self._recommend_hybrid(auth_account_id, user_profile)
        else:
            logging.error(f"Nieznany tryb rekomendacji: {mode}")
            return []

    def get_plan_details(self, plan_ids: List[int]) -> Dict[int, Dict]:
        """
        Pobiera szczeg√≥≈Çy plan√≥w treningowych.
        
        Args:
            plan_ids: Lista ID plan√≥w do pobrania
            
        Returns:
            S≈Çownik {plan_id: szczeg√≥≈Çy_planu}
        """
        if not self.conn or not plan_ids:
            return {}
            
        with self.conn.cursor() as cur:
            placeholders = ','.join(['%s'] * len(plan_ids))
            cur.execute(f"""
                SELECT id, name, description, goal_type, difficulty_level, 
                       training_days_per_week, equipment_required
                FROM training_plans 
                WHERE id IN ({placeholders})
            """, plan_ids)
            
            plans = {}
            for row in cur.fetchall():
                plans[row[0]] = {
                    'id': row[0],
                    'name': row[1],
                    'description': row[2],
                    'goal_type': row[3],
                    'difficulty_level': row[4],
                    'training_days_per_week': row[5],
                    'equipment_required': row[6]
                }
            
            return plans

    def close_connection(self):
        """Zamyka po≈ÇƒÖczenie z bazƒÖ danych."""
        if self.conn:
            self.conn.close()
            logging.info("üîå Po≈ÇƒÖczenie z bazƒÖ danych zosta≈Ço zamkniƒôte.")

    def get_user_match_reasons(self, auth_account_id: int, plan_id: int) -> List[str]:
        """
        Generuje listƒô powod√≥w dopasowania planu do u≈ºytkownika.
        
        Args:
            auth_account_id: ID u≈ºytkownika
            plan_id: ID planu
            
        Returns:
            Lista string√≥w z powodami dopasowania
        """
        if not self.conn:
            return []
            
        user_profile = self._get_user_profile(auth_account_id)
        if not user_profile:
            return []
            
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT goal_type, difficulty_level, training_days_per_week, equipment_required
                FROM training_plans 
                WHERE id = %s
            """, (plan_id,))
            
            plan_data = cur.fetchone()
            if not plan_data:
                return []
            
            plan_goal, plan_level, plan_days, plan_equipment = plan_data
            reasons = []
            
            # Sprawd≈∫ dopasowania
            if plan_goal == user_profile['goal']:
                goal_labels = {
                    'masa': 'budowanie masy miƒô≈õniowej',
                    'redukcja': 'redukcja tkanki t≈Çuszczowej', 
                    'si≈Ça': 'zwiƒôkszenie si≈Çy'
                }
                reasons.append(f"Dopasowany cel: {goal_labels.get(plan_goal, plan_goal)}")
                
            if plan_level == user_profile['level']:
                level_labels = {
                    'poczatkujacy': 'poziom poczƒÖtkujƒÖcy',
                    'sredniozaawansowany': 'poziom ≈õredniozaawansowany',
                    'zaawansowany': 'poziom zaawansowany'
                }
                reasons.append(f"Odpowiedni {level_labels.get(plan_level, plan_level)}")
                
            if plan_days == user_profile['days']:
                reasons.append(f"{plan_days} dni treningowych w tygodniu")
                
            if plan_equipment == user_profile['equipment']:
                equipment_labels = {
                    'silownia_full': 'pe≈Çna si≈Çownia',
                    'wolne_ciezary': 'wolne ciƒô≈ºary',
                    'dom_kalistenika': 'ƒáwiczenia w domu'
                }
                reasons.append(f"Dostosowany do: {equipment_labels.get(plan_equipment, plan_equipment)}")
            
            return reasons

    def get_popularity_score(self, plan_id: int) -> int:
        """
        Oblicza wynik popularno≈õci planu na podstawie liczby aktywacji.
        
        Args:
            plan_id: ID planu
            
        Returns:
            Liczba aktywacji planu
        """
        if not self.conn:
            return 0
            
        with self.conn.cursor() as cur:
            cur.execute("""
                SELECT COUNT(*) as activation_count
                FROM user_active_plans 
                WHERE plan_id = %s
            """, (plan_id,))
            
            result = cur.fetchone()
            return result[0] if result else 0


# Przyk≈Çad u≈ºycia i testowanie
if __name__ == '__main__':
    # Parametry po≈ÇƒÖczenia z bazƒÖ
    db_parameters = {
        "dbname": "LaskoDB", 
        "user": "postgres", 
        "password": "postgres", 
        "host": "localhost", 
        "port": "5432"
    }

    # Scenariusze testowe
    test_scenarios = [
        {"account_id": 10, "description": "Konto testowe 1"},
        {"account_id": 55, "description": "Konto testowe 2"},
    ]

    # Inicjalizacja serwisu
    reco_service = RecommendationService(db_parameters)

    if reco_service.conn:
        for scenario in test_scenarios:
            account_id = scenario["account_id"]
            print(f"\n{'='*70}")
            print(f"Test dla Konta ID: {account_id} ({scenario['description']})")
            print(f"{'='*70}")
            
            # Pobierz profil u≈ºytkownika
            user_profile = reco_service._get_user_profile(account_id)
            if user_profile:
                print("üë§ Profil u≈ºytkownika:")
                print(f"   - Cel: {user_profile['goal']}")
                print(f"   - Poziom: {user_profile['level']}")
                print(f"   - Dni: {user_profile['days']}")
                print(f"   - Sprzƒôt: {user_profile['equipment']}")
            else:
                print(f"üë§ Nie znaleziono profilu dla konta o ID {account_id}.")
                continue
            
            # Test wszystkich tryb√≥w
            for mode in ['produkt', 'klient', 'hybrydowo']:
                recommendations = reco_service.get_recommendations(account_id, mode=mode)
                
                print(f"\n--- Tryb: {mode.upper()} ---")
                if recommendations:
                    print("‚ú® Top 5 rekomendacji:")
                    top_plan_ids = [r['plan_id'] for r in recommendations[:5]]
                    plan_details = reco_service.get_plan_details(top_plan_ids)
                    
                    for reco in recommendations[:5]:
                        plan_id = reco['plan_id']
                        score = reco['score']
                        plan = plan_details.get(plan_id, {})
                        popularity = reco_service.get_popularity_score(plan_id)
                        match_reasons = reco_service.get_user_match_reasons(account_id, plan_id)
                        
                        print(f"   - Plan ID: {plan_id:<5} | Wynik: {score:.2f} | Popularno≈õƒá: {popularity}")
                        print(f"     Nazwa: {plan.get('name', 'Nieznany plan')}")
                        if match_reasons:
                            print(f"     Dopasowanie: {', '.join(match_reasons)}")
                        print()
                else:
                    print("   - Brak rekomendacji.")
    
    reco_service.close_connection()
    print("\nüéØ Testowanie algorytm√≥w rekomendacji zako≈Ñczone.")